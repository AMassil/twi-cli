#!/usr/bin/env bash

# twi-cli - A CLI tool for Twitch, heavily inspired by ani-cli
# Version: 2.1.0 (Robust JQ Parsing & Intuitive List Management)

# ==============================================================================
# GLOBAL VARIABLES & PATHS
# ==============================================================================
APP_NAME="twi-cli"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/${APP_NAME}"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/${APP_NAME}"
CONFIG_FILE="${CONFIG_DIR}/config"
FOLLOWED_FILE="${CONFIG_DIR}/followed.txt"
FOLLOWS_CACHE="${CACHE_DIR}/follows_live.json"

# Twitch Public Web Client-ID (Used by Twitch Web Client)
CLIENT_ID="kimne78kx3ncx6brgo4mv6wki5h1ko"
GQL_URL="https://gql.twitch.tv/gql"

# ==============================================================================
# COLORS & FORMATTING
# ==============================================================================
# Terminal Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Safe Raw ANSI Escape Codes (For safe jq injection)
C_RED=$(printf '\033[31m')
C_GREEN=$(printf '\033[32m')
C_YELLOW=$(printf '\033[33m')
C_CYAN=$(printf '\033[36m')
C_RESET=$(printf '\033[0m')

# ==============================================================================
# CORE UTILITY FUNCTIONS
# ==============================================================================
trap 'echo -e "${RED}\nOperation aborted by user.${NC}"; exit 130' INT

check_dependencies() {
    local missing_deps=()
    for cmd in curl jq fzf streamlink mpv sed wc tr sort grep awk; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo -e "${RED}Error: Missing dependencies: ${missing_deps[*]}${NC}"
        echo -e "Please install them on your Ubuntu system using:"
        echo -e "${GREEN}sudo apt update && sudo apt install curl jq fzf streamlink mpv coreutils grep gawk${NC}"
        exit 1
    fi
}

create_default_config() {
    cat <<EOF > "$CONFIG_FILE"
# $APP_NAME configuration file

# Streamlink defaults
DEFAULT_QUALITY="best"
DEFAULT_PLAYER="mpv"
LOW_LATENCY="true"
DISABLE_ADS="true"
EOF
}

cleanup_followed_file() {
    # This safely extracts only valid channels, sorts them, and rewrites the file with a helpful header
    local temp_list
    if [ -f "$FOLLOWED_FILE" ]; then
        temp_list=$(grep -v '^#' "$FOLLOWED_FILE" 2>/dev/null | awk 'NF' | tr '[:upper:]' '[:lower:]' | tr -d '\r' | sort -u)
    fi

    cat <<EOF > "$FOLLOWED_FILE"
# ==================================================
# TWITCH FOLLOWED CHANNELS LIST
# ==================================================
# Add the exact channel names you want to track.
# One channel name per line.
# Lines starting with "#" are ignored.
#
# Examples:
# shroud
# tarik
# riotgames
# ==================================================
EOF

    if [ -n "$temp_list" ]; then
        echo "$temp_list" >> "$FOLLOWED_FILE"
    fi
}

init_env() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -d "$CACHE_DIR" ]; then
        mkdir -p "$CACHE_DIR"
    fi

    if [ ! -f "$CONFIG_FILE" ]; then
        create_default_config
    fi

    if [ ! -f "$FOLLOWED_FILE" ]; then
        cleanup_followed_file
    fi

    # Initialize defaults as fallback
    DEFAULT_QUALITY="best"
    DEFAULT_PLAYER="mpv"
    LOW_LATENCY="true"
    DISABLE_ADS="true"

    # Source the config file
    source "$CONFIG_FILE"
}

print_header() {
    clear
    echo -e "${MAGENTA}"
    cat << "EOF"
  _             _             _ _ 
 | |___      __(_)        ___| (_)
 | __\ \ /\ / /| |_____  / __| | |
 | |_ \ V  V / | |_____| (__ | | |
  \__| \_/\_/  |_|        \___|_|_|
EOF
    echo -e "${NC}         A CLI tool for Twitch\n"
}

# ==============================================================================
# TWITCH API (GQL) FUNCTIONS
# ==============================================================================
gql_request() {
    local payload="$1"
    local headers=(
        "-H" "Client-Id: $CLIENT_ID"
        "-H" "Content-Type: application/json"
    )

    curl -s -X POST "$GQL_URL" "${headers[@]}" -d "$payload"
}

check_api_error() {
    local response="$1"
    if [ -z "$response" ]; then
        echo -e "${RED}Error: Empty response from Twitch API.${NC}"
        sleep 2
        return 1
    fi

    local has_errors
    has_errors=$(echo "$response" | jq -r '.errors | length' 2>/dev/null)
    if [ "$has_errors" != "0" ] && [ "$has_errors" != "" ] && [ "$has_errors" != "null" ]; then
        local error_msg
        error_msg=$(echo "$response" | jq -r '.errors[0].message' 2>/dev/null)
        echo -e "${RED}Twitch API Error: $error_msg${NC}"
        sleep 4
        return 1
    fi
    return 0
}

# ==============================================================================
# SETTINGS & LOCAL FOLLOWS MANAGEMENT
# ==============================================================================
change_quality() {
    local options="best\n1080p60\n1080p\n720p60\n720p\n480p\n360p\nworst\naudio_only"
    local new_quality
    new_quality=$(echo -e "$options" | fzf --prompt="Select Quality > " --height=12 --layout=reverse --border=rounded) || true

    if [ -n "$new_quality" ]; then
        sed -i "s/^DEFAULT_QUALITY=.*/DEFAULT_QUALITY=\"$new_quality\"/" "$CONFIG_FILE"
        DEFAULT_QUALITY="$new_quality"
        echo -e "${GREEN}Quality updated to $new_quality!${NC}"
        sleep 1
    fi
}

change_player() {
    local options="mpv\nvlc\nffplay"
    local new_player
    new_player=$(echo -e "$options" | fzf --prompt="Select Player > " --height=10 --layout=reverse --border=rounded) || true

    if [ -n "$new_player" ]; then
        sed -i "s/^DEFAULT_PLAYER=.*/DEFAULT_PLAYER=\"$new_player\"/" "$CONFIG_FILE"
        DEFAULT_PLAYER="$new_player"
        echo -e "${GREEN}Player updated to $new_player!${NC}"
        sleep 1
    fi
}

toggle_setting() {
    local setting_name="$1"
    local current_val="${!setting_name}"
    local new_val

    if [ "$current_val" == "true" ]; then
        new_val="false"
    else
        new_val="true"
    fi

    sed -i "s/^${setting_name}=.*/${setting_name}=\"${new_val}\"/" "$CONFIG_FILE"
    eval "${setting_name}=\"${new_val}\""
    echo -e "${GREEN}${setting_name} successfully set to ${new_val}!${NC}"
    sleep 1
}

settings_menu() {
    while true; do
        print_header
        local options="1. Change Default Quality (Current: $DEFAULT_QUALITY)\n2. Change Default Player (Current: $DEFAULT_PLAYER)\n3. Toggle Low Latency (Current: $LOW_LATENCY)\n4. Toggle Ad Block (Current: $DISABLE_ADS)\n5. Edit Config File Manually\n6. Back"

        local choice
        choice=$(echo -e "$options" | fzf --prompt="Settings > " --height=15 --layout=reverse --border=rounded) || true
        choice="${choice%%.*}" # Strip everything after the dot

        case "$choice" in
            1) change_quality ;;
            2) change_player ;;
            3) toggle_setting "LOW_LATENCY" ;;
            4) toggle_setting "DISABLE_ADS" ;;
            5) 
                ${EDITOR:-nano} "$CONFIG_FILE"
                source "$CONFIG_FILE" # Reload after arbitrary manual edits
                ;;
            6|*) return ;;
        esac
    done
}

manage_follows_menu() {
    while true; do
        print_header
        echo -e "${CYAN}--- Manage Local Followed Channels ---${NC}"
        
        # Count only active lines (not comments, not blank)
        local count
        count=$(grep -v '^#' "$FOLLOWED_FILE" 2>/dev/null | awk 'NF' | wc -l || echo 0)
        echo -e "Currently tracking: ${GREEN}${count}${NC} channels\n"

        local options="1. âž• Add a Channel\n2. âž– Remove a Channel\n3. ðŸ“‚ Import from Text File\n4. ðŸ“ Edit List Manually\n5. ðŸ”™ Back to Main Menu"

        local choice
        choice=$(echo -e "$options" | fzf --prompt="Manage Follows > " --height=15 --layout=reverse --border=rounded) || true
        choice="${choice%%.*}"

        case "$choice" in
            1)
                echo -ne "${CYAN}Enter exact channel name to add: ${NC}"
                read -r new_chan
                if [ -n "$new_chan" ]; then
                    echo "$new_chan" >> "$FOLLOWED_FILE"
                    cleanup_followed_file
                    echo -e "${GREEN}Added '$new_chan' to your follows!${NC}"
                    sleep 1
                fi
                ;;
            2)
                if [ "$count" -eq 0 ]; then
                    echo -e "${RED}Your list is empty.${NC}"
                    sleep 2
                else
                    local to_remove
                    to_remove=$(grep -v '^#' "$FOLLOWED_FILE" | awk 'NF' | fzf --prompt="Select channel to remove > " --height=15 --layout=reverse --border=rounded) || true
                    if [ -n "$to_remove" ]; then
                        # Remove the exact line matching the channel and cleanup
                        grep -v -w -x "$to_remove" "$FOLLOWED_FILE" > "${FOLLOWED_FILE}.tmp" && mv "${FOLLOWED_FILE}.tmp" "$FOLLOWED_FILE"
                        cleanup_followed_file
                        echo -e "${GREEN}Removed '$to_remove'.${NC}"
                        sleep 1
                    fi
                fi
                ;;
            3)
                clear
                echo -e "${CYAN}====================================================${NC}"
                echo -e "${YELLOW}                 IMPORT CHANNELS                    ${NC}"
                echo -e "${CYAN}====================================================${NC}"
                echo -e "To import channels, create a text file on your PC."
                echo -e "The file must contain ${GREEN}ONE channel username per line${NC}."
                echo -e ""
                echo -e "${MAGENTA}Example File Format:${NC}"
                echo -e "  shroud"
                echo -e "  tarik"
                echo -e "  hasanabi"
                echo -e "  riotgames"
                echo -e "${CYAN}====================================================${NC}"
                echo -ne "${YELLOW}Enter absolute path to your file (or press Enter to cancel): ${NC}"
                read -r file_path

                if [ -n "$file_path" ] && [ -f "$file_path" ]; then
                    cat "$file_path" >> "$FOLLOWED_FILE"
                    cleanup_followed_file
                    echo -e "${GREEN}Channels imported successfully!${NC}"
                    sleep 2
                elif [ -n "$file_path" ]; then
                    echo -e "${RED}File not found at: $file_path${NC}"
                    sleep 2
                fi
                ;;
            4)
                ${EDITOR:-nano} "$FOLLOWED_FILE"
                cleanup_followed_file
                ;;
            5|*) return ;;
        esac
    done
}

# ==============================================================================
# FEATURE OPERATIONS
# ==============================================================================
sync_local_follows() {
    # Extract only non-comment, non-empty lines
    mapfile -t ALL_LOGINS < <(grep -v '^#' "$FOLLOWED_FILE" 2>/dev/null | awk 'NF')
    local total=${#ALL_LOGINS[@]}

    if [ "$total" -eq 0 ]; then
        echo -e "${YELLOW}Your follow list is empty.${NC}"
        echo -e "Please add channels via ${GREEN}'Manage Followed Channels'${NC} in the Main Menu."
        sleep 4
        return 1
    fi

    echo -e "${CYAN}Checking live status of $total followed channels...${NC}"

    > "$FOLLOWS_CACHE" # Clear the cache file

    # Twitch allows querying 100 users at a time. We batch by 100.
    for (( i=0; i<total; i+=100 )); do
        local batch=("${ALL_LOGINS[@]:$i:100}")
        
        # Build JSON array of logins
        local logins_json
        logins_json=$(printf '%s\n' "${batch[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0))')
        
        # Build GQL payload
        local payload
        payload=$(jq -n --argjson logins "$logins_json" '{
          query: "query ($logins: [String!]) { users(logins: $logins) { login displayName stream { title viewersCount game { name } } } }",
          variables: { logins: $logins }
        }')
        
        local response
        response=$(gql_request "$payload")

        check_api_error "$response" || continue

        # Filter ONLY channels that are currently LIVE (stream != null)
        echo "$response" | jq -c '.data.users[] | select(.stream != null)' >> "$FOLLOWS_CACHE"
    done

    local live_count
    live_count=$(wc -l < "$FOLLOWS_CACHE" 2>/dev/null || echo 0)
    echo -e "${GREEN}Scan complete! $live_count of your channels are currently live.${NC}"
    sleep 1
}

watch_followed() {
    sync_local_follows || return 1

    local count
    count=$(wc -l < "$FOLLOWS_CACHE" 2>/dev/null || echo 0)

    if [ "$count" -eq 0 ]; then
        echo -e "${YELLOW}None of your followed channels are currently live.${NC}"
        sleep 3
        return 1
    fi

    # Using safely injected ANSI variables to completely bypass jq parsing errors
    local selected
    selected=$(cat "$FOLLOWS_CACHE" | jq -r \
        --arg cg "$C_GREEN" \
        --arg cy "$C_YELLOW" \
        --arg cc "$C_CYAN" \
        --arg rs "$C_RESET" '
        "\(.login)|||\($cg)\(.displayName)\($rs) (\($cy)\(.stream.viewersCount // 0)\($rs) viewers) - \($cc)\(.stream.game.name // "No Category" | gsub("\n"; " "))\($rs) | \(.stream.title // "No Title" | gsub("\n"; " "))"
    ' | fzf --ansi --prompt="Watch Followed > " --delimiter="\\|\\|\\|" --with-nth=2 --height=80% --layout=reverse --border=rounded) || true

    if [ -n "$selected" ]; then
        local login="${selected%%|||*}"
        play_stream "$login"
    fi
}

top_streams() {
    echo -e "${YELLOW}Fetching Top Live Streams globally...${NC}"

    local payload
    payload=$(jq -n '{
      query: "query { streams(first: 30) { edges { node { broadcaster { login displayName } title viewersCount game { name } } } } }"
    }')
    
    local response
    response=$(gql_request "$payload")

    check_api_error "$response" || return 1

    local selected_stream
    selected_stream=$(echo "$response" | jq -r \
        --arg cg "$C_GREEN" \
        --arg cy "$C_YELLOW" \
        --arg cc "$C_CYAN" \
        --arg rs "$C_RESET" '
        .data.streams.edges[].node | "\(.broadcaster.login)|||\($cg)\(.broadcaster.displayName)\($rs) (\($cy)\(.viewersCount // 0)\($rs) viewers) - \($cc)\(.game.name // "No Category" | gsub("\n"; " "))\($rs) | \(.title // "No Title" | gsub("\n"; " "))"
    ' | fzf --ansi --prompt="Select Top Stream > " --delimiter="\\|\\|\\|" --with-nth=2 --height=80% --layout=reverse --border=rounded) || true

    if [ -n "$selected_stream" ]; then
        local login="${selected_stream%%|||*}"
        play_stream "$login"
    fi
}

search_games_and_watch() {
    echo -ne "${CYAN}Enter game/category name to search: ${NC}"
    read -r game_query

    if [ -z "$game_query" ]; then
        return
    fi

    echo -e "${YELLOW}Searching for '$game_query'...${NC}"
    
    local payload
    payload=$(jq -n --arg q "$game_query" '{
      query: "query ($q: String!) { searchFor(userQuery: $q, platform: \"web\") { games { edges { item { ... on Game { name } } } } } }",
      variables: { q: $q }
    }')
    
    local response
    response=$(gql_request "$payload")

    check_api_error "$response" || return 1

    local result_count
    result_count=$(echo "$response" | jq -r '.data.searchFor.games.edges | length' 2>/dev/null || echo 0)
    if [ "$result_count" -eq 0 ]; then
        echo -e "${RED}No categories found.${NC}"
        sleep 2
        return
    fi

    local selected_game
    selected_game=$(echo "$response" | jq -r \
        --arg cc "$C_CYAN" \
        --arg rs "$C_RESET" '
        .data.searchFor.games.edges[].item | select(.name != null) | "\(.name | gsub("\n"; " "))|||\($cc)\(.name | gsub("\n"; " "))\($rs)"
    ' | fzf --ansi --prompt="Select Category > " --delimiter="\\|\\|\\|" --with-nth=2 --height=80% --layout=reverse --border=rounded) || true

    if [ -n "$selected_game" ]; then
        local game_name="${selected_game%%|||*}"
        show_streams_for_game "$game_name"
    fi
}

show_streams_for_game() {
    local game_name="$1"
    echo -e "${YELLOW}Fetching top streams for '$game_name'...${NC}"

    local payload
    payload=$(jq -n --arg g "$game_name" '{
      query: "query ($g: String!) { game(name: $g) { streams(first: 30) { edges { node { broadcaster { login displayName } viewersCount title } } } } }",
      variables: { g: $g }
    }')
    
    local response
    response=$(gql_request "$payload")

    check_api_error "$response" || return 1

    local is_null
    is_null=$(echo "$response" | jq -r '.data.game')
    if [ "$is_null" == "null" ]; then
        echo -e "${RED}Game exact match not found or no streams currently available.${NC}"
        sleep 3
        return
    fi

    local result_count
    result_count=$(echo "$response" | jq -r '.data.game.streams.edges | length' 2>/dev/null || echo 0)
    if [ "$result_count" -eq 0 ]; then
        echo -e "${RED}No live streams found for this category right now.${NC}"
        sleep 3
        return
    fi

    local selected_stream
    selected_stream=$(echo "$response" | jq -r \
        --arg cg "$C_GREEN" \
        --arg cy "$C_YELLOW" \
        --arg rs "$C_RESET" '
        .data.game.streams.edges[].node | "\(.broadcaster.login)|||\($cg)\(.broadcaster.displayName)\($rs) (\($cy)\(.viewersCount // 0)\($rs) viewers) | \(.title // "No Title" | gsub("\n"; " "))"
    ' | fzf --ansi --prompt="Select Stream ($game_name) > " --delimiter="\\|\\|\\|" --with-nth=2 --height=80% --layout=reverse --border=rounded) || true

    if [ -n "$selected_stream" ]; then
        local login="${selected_stream%%|||*}"
        play_stream "$login"
    fi
}

search_channels_and_watch() {
    echo -ne "${CYAN}Enter channel name to search: ${NC}"
    read -r channel_query

    if [ -z "$channel_query" ]; then
        return
    fi

    echo -e "${YELLOW}Searching for '$channel_query'...${NC}"
    
    local payload
    payload=$(jq -n --arg q "$channel_query" '{
      query: "query ($q: String!) { searchFor(userQuery: $q, platform: \"web\") { channels { edges { item { ... on User { login displayName stream { type game { name } } } } } } } }",
      variables: { q: $q }
    }')
    
    local response
    response=$(gql_request "$payload")

    check_api_error "$response" || return 1

    local result_count
    result_count=$(echo "$response" | jq -r '.data.searchFor.channels.edges | length' 2>/dev/null || echo 0)
    if [ "$result_count" -eq 0 ]; then
        echo -e "${RED}No channels found matching that query.${NC}"
        sleep 2
        return
    fi

    local selected_channel
    selected_channel=$(echo "$response" | jq -r \
        --arg cg "$C_GREEN" \
        --arg cc "$C_CYAN" \
        --arg cr "$C_RED" \
        --arg rs "$C_RESET" '
        .data.searchFor.channels.edges[].item | select(.login != null) | "\(.login)|||\($cg)\(.displayName)\($rs) - \(if .stream != null then "\($cg)LIVE\($rs) (\($cc)\(.stream.game.name // "No Category" | gsub("\n"; " "))\($rs))" else "\($cr)OFFLINE\($rs)" end)"
    ' | fzf --ansi --prompt="Select Channel > " --delimiter="\\|\\|\\|" --with-nth=2 --height=80% --layout=reverse --border=rounded) || true

    if [ -n "$selected_channel" ]; then
        local login="${selected_channel%%|||*}"
        play_stream "$login"
    fi
}

play_stream() {
    local channel="$1"

    if [ -z "$channel" ]; then
        echo -e "${RED}Error: Failed to parse channel name.${NC}"
        sleep 2
        return 1
    fi

    clear
    echo -e "${MAGENTA}====================================================${NC}"
    echo -e "${GREEN}Starting Stream:  ${CYAN}${channel}${NC}"
    echo -e "${GREEN}Video Player:     ${CYAN}${DEFAULT_PLAYER}${NC}"
    echo -e "${GREEN}Video Quality:    ${CYAN}${DEFAULT_QUALITY}${NC}"
    echo -e "${GREEN}Low Latency:      ${CYAN}${LOW_LATENCY}${NC}"
    echo -e "${GREEN}Ad Block:         ${CYAN}${DISABLE_ADS}${NC}"
    echo -e "${MAGENTA}====================================================${NC}"

    COMMAND="streamlink \"twitch.tv/${channel}\" \"${DEFAULT_QUALITY}\" --player=\"${DEFAULT_PLAYER}\""

    if [ "$LOW_LATENCY" == "true" ]; then
        COMMAND="$COMMAND --twitch-low-latency"
    fi

    if [ "$DISABLE_ADS" == "true" ]; then
        COMMAND="$COMMAND --twitch-disable-ads"
    fi

    if ! eval "$COMMAND"; then
        echo -e "\n${RED}Streamlink encountered an error.${NC}"
        echo -e "Make sure the stream is online, and your chosen video player is installed."
        echo -e "Press Enter to return to the menu..."
        read -r
    else
        echo -e "\n${MAGENTA}====================================================${NC}"
        echo -e "${GREEN}Stream ended or player closed successfully.${NC}"
        echo -e "Press Enter to return to main menu..."
        read -r
    fi
}

# ==============================================================================
# ENTRY POINTS & MENUS
# ==============================================================================
main_menu() {
    while true; do
        print_header
        local options="1. Watch Live Followed Channels\n2. Manage Followed Channels\n3. Watch Top Live Streams\n4. Search Games / Categories\n5. Search Channels\n6. Watch Specific Channel (Manual Input)\n7. Settings\n8. Exit"

        local choice
        choice=$(echo -e "$options" | fzf --prompt="Main Menu > " --height=20 --layout=reverse --border=rounded) || true
        choice="${choice%%.*}" # Strip everything after the dot for safety

        case "$choice" in
            1) watch_followed ;;
            2) manage_follows_menu ;;
            3) top_streams ;;
            4) search_games_and_watch ;;
            5) search_channels_and_watch ;;
            6) 
                echo -ne "${CYAN}Enter exact channel name: ${NC}"
                read -r manual_channel
                if [ -n "$manual_channel" ]; then
                    play_stream "$manual_channel"
                fi
                ;;
            7) settings_menu ;;
            8) clear; echo -e "${GREEN}Goodbye!${NC}"; exit 0 ;;
            *) exit 0 ;; # Catches ESC in fzf root menu
        esac
    done
}

usage() {
    echo -e "${CYAN}${APP_NAME} - A CLI tool for Twitch${NC}"
    echo "Usage:"
    echo "  $0                 Launch interactive menu"
    echo "  $0 [channel]       Watch a specific channel directly (e.g. $0 shroud)"
    echo "  $0 --help          Show this help message"
}

main() {
    check_dependencies
    init_env

    if [ $# -gt 0 ]; then
        case "$1" in
            --help|-h)
                usage
                exit 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                usage
                exit 1
                ;;
            *)
                play_stream "$1"
                exit 0
                ;;
        esac
    else
        main_menu
    fi
}

# Kickstart Execution
main "$@"
